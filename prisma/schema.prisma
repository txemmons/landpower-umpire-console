generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

model Game {
  id                String   @id @default(cuid())
  name              String
  currentTurnNumber Int      @default(1)
  // store as string instead of enum
  currentPhase      String   @default("INFO_COLLECTION")
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  turns      Turn[]
  units      Unit[]
  unitStates UnitState[] // âœ… back-relation fix
  actions    Action[]
  logEntry   LogEntry[]
}

model Turn {
  id         String    @id @default(cuid())
  gameId     String
  turnNumber Int
  phase      String
  startedAt  DateTime  @default(now())
  endedAt    DateTime?

  game Game @relation(fields: [gameId], references: [id], onDelete: Cascade)

  @@index([gameId, turnNumber])
}

model Unit {
  id           String   @id @default(cuid())
  gameId       String
  name         String
  side         String
  echelon      String
  unitType     String
  parentUnitId String?
  notes        String   @default("")
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  game      Game       @relation(fields: [gameId], references: [id], onDelete: Cascade)
  parent    Unit?      @relation("UnitParent", fields: [parentUnitId], references: [id])
  children  Unit[]     @relation("UnitParent")
  unitState UnitState?
}

model UnitState {
  id              String   @id @default(cuid())
  unitId          String   @unique
  gameId          String
  cppCurrent      Int
  cppMax          Int?
  suppressedFire  Boolean  @default(false)
  suppressedCyber Boolean  @default(false)
  suppressedEW    Boolean  @default(false)
  posture         String?
  destroyed       Boolean  @default(false)
  updatedAt       DateTime @updatedAt

  unit Unit @relation(fields: [unitId], references: [id], onDelete: Cascade)
  game Game @relation(fields: [gameId], references: [id], onDelete: Cascade)
}

model Action {
  id             String       @id @default(cuid())
  gameId         String
  turnNumber     Int
  phase          String
  actionType     String
  actorSide      String
  title          String
  inputsJson     String
  proposedJson   String?
  finalJson      String?
  status         String @default("DRAFT")
  overrideReason String?
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt

  // SQLite-compatible: store JSON as text
  inputsJson   String
  proposedJson String?
  finalJson    String?

  status         String   @default("DRAFT")
  overrideReason String?
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  game     Game       @relation(fields: [gameId], references: [id], onDelete: Cascade)
  dieRolls DieRoll[]
  logs     LogEntry[]

  @@index([gameId, turnNumber])
}

model DieRoll {
  id        String   @id @default(cuid())
  actionId  String
  dieType   String
  result    Int
  label     String?
  createdAt DateTime @default(now())

  action Action @relation(fields: [actionId], references: [id], onDelete: Cascade)
}

model LogEntry {
  id         String   @id @default(cuid())
  gameId     String
  turnNumber Int
  phase      String
  actionId   String?
  message    String
  createdAt  DateTime @default(now())

  game   Game    @relation(fields: [gameId], references: [id], onDelete: Cascade)
  action Action? @relation(fields: [actionId], references: [id], onDelete: SetNull)

  @@index([gameId, createdAt])
}
